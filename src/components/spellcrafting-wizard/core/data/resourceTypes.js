/**
 * Resource Types Module
 * 
 * Defines resource types used in the effect system, including standard
 * resources like action points and mana, as well as class-specific resources.
 */

/**
 * Standard resource types available to all characters
 */
export const STANDARD_RESOURCE_TYPES = [
    {
      id: 'actionPoints',
      name: 'Action Points',
      shortName: 'AP',
      description: 'Used to perform actions in combat',
      color: '#4e9df5',
      icon: 'spell_nature_timestop',
      defaultMax: 5,
      defaultRegen: 3,
      regenTrigger: 'startOfTurn',
      affectedBy: ['intelligence', 'level', 'class'],
      formula: 'baseActionPoints + intelligenceMod + classBonusPoints',
      useVerb: 'spend',
      gainVerb: 'gain',
      vital: true,
      displayPriority: 1
    },
    {
      id: 'mana',
      name: 'Mana',
      shortName: 'MP',
      description: 'Magical energy used to cast spells',
      color: '#25a6e0',
      icon: 'spell_arcane_arcane02',
      defaultMax: 100,
      defaultRegen: 5,
      regenTrigger: 'rest',
      affectedBy: ['intelligence', 'spirit', 'level'],
      formula: 'baseMana + (intelligenceMod * 10) + (spiritMod * 5) + (level * 5)',
      useVerb: 'spend',
      gainVerb: 'restore',
      vital: true,
      displayPriority: 2
    },
    {
      id: 'health',
      name: 'Health',
      shortName: 'HP',
      description: 'Represents physical well-being and vitality',
      color: '#e02525',
      icon: 'spell_holy_sealofsacrifice',
      defaultMax: 10,
      defaultRegen: 0,
      regenTrigger: 'rest',
      affectedBy: ['constitution', 'level', 'class'],
      formula: 'classBaseHP + (constitutionMod * level) + bonusHP',
      useVerb: 'lose',
      gainVerb: 'heal',
      vital: true,
      displayPriority: 0
    },
    {
      id: 'energy',
      name: 'Energy',
      shortName: 'EN',
      description: 'Physical stamina used for special abilities',
      color: '#f9e825',
      icon: 'inv_alchemy_elixir_05',
      defaultMax: 100,
      defaultRegen: 10,
      regenTrigger: 'outOfCombat',
      affectedBy: ['agility', 'constitution'],
      formula: 'baseEnergy + (agilityMod * 5) + (constitutionMod * 10)',
      useVerb: 'spend',
      gainVerb: 'restore',
      vital: false,
      displayPriority: 3
    },
    {
      id: 'rage',
      name: 'Rage',
      shortName: 'RG',
      description: 'Combat fury that builds through dealing and taking damage',
      color: '#e84c38',
      icon: 'ability_warrior_rampage',
      defaultMax: 100,
      defaultRegen: -5, // Degenerates outside of combat
      regenTrigger: 'dealDamage',
      affectedBy: ['strength', 'combatActivity'],
      formula: 'baseAmount + (damageDealt / 5) + (damageTaken / 3)',
      useVerb: 'spend',
      gainVerb: 'build',
      vital: false,
      displayPriority: 3
    },
    {
      id: 'comboPoints',
      name: 'Combo Points',
      shortName: 'CP',
      description: 'Accumulated points used for executing finishing moves',
      color: '#8d3de8',
      icon: 'ability_rogue_eviscerate',
      defaultMax: 5,
      defaultRegen: 0, // Generated through specific abilities
      regenTrigger: 'ability',
      affectedBy: ['agility', 'abilities'],
      formula: 'Generated by specific abilities, spent on finishers',
      useVerb: 'consume',
      gainVerb: 'generate',
      vital: false,
      displayPriority: 4
    }
  ];
  
  /**
   * Class-specific resource types
   */
  export const CLASS_RESOURCE_TYPES = [
    {
      id: 'soulShards',
      name: 'Soul Shards',
      shortName: 'SS',
      description: 'Soul fragments used for powerful warlock spells',
      color: '#8745e0',
      icon: 'spell_shadow_soulgem',
      defaultMax: 5,
      defaultRegen: 0, // Generated through specific abilities
      regenTrigger: 'killing',
      classRestriction: 'warlock',
      affectedBy: ['spiritMod', 'killType'],
      formula: 'Generated by killing enemies or using specific abilities',
      useVerb: 'consume',
      gainVerb: 'harvest',
      vital: false,
      displayPriority: 3
    },
    {
      id: 'holyPower',
      name: 'Holy Power',
      shortName: 'HP',
      description: 'Divine energy used for paladin abilities',
      color: '#f2e596',
      icon: 'spell_holy_divinepurpose',
      defaultMax: 5,
      defaultRegen: 0, // Generated through specific abilities
      regenTrigger: 'ability',
      classRestriction: 'paladin',
      affectedBy: ['charisma', 'abilities'],
      formula: 'Generated by specific abilities, consumed for powerful effects',
      useVerb: 'expend',
      gainVerb: 'generate',
      vital: false,
      displayPriority: 3
    },
    {
      id: 'focus',
      name: 'Focus',
      shortName: 'FC',
      description: 'Concentration used for hunter abilities',
      color: '#e5a561',
      icon: 'ability_hunter_focusfire',
      defaultMax: 100,
      defaultRegen: 10,
      regenTrigger: 'passive',
      classRestriction: 'hunter',
      affectedBy: ['agility', 'level'],
      formula: 'baseFocus + (agilityMod * 5) + (level * 2)',
      useVerb: 'spend',
      gainVerb: 'regain',
      vital: false,
      displayPriority: 3
    },
    {
      id: 'ki',
      name: 'Ki',
      shortName: 'KI',
      description: 'Spiritual energy used for monk abilities',
      color: '#78dc78',
      icon: 'ability_monk_chiwave',
      defaultMax: 20,
      defaultRegen: 1,
      regenTrigger: 'startOfTurn',
      classRestriction: 'monk',
      affectedBy: ['spirit', 'level'],
      formula: 'baseKi + spiritMod + level',
      useVerb: 'channel',
      gainVerb: 'focus',
      vital: false,
      displayPriority: 3
    },
    {
      id: 'astralPower',
      name: 'Astral Power',
      shortName: 'AP',
      description: 'Celestial energy used for druid balance abilities',
      color: '#4287f5',
      icon: 'ability_druid_eclipse',
      defaultMax: 100,
      defaultRegen: 0, // Generated through specific abilities
      regenTrigger: 'ability',
      classRestriction: 'druid',
      specializationRestriction: 'balance',
      affectedBy: ['intelligence', 'abilities'],
      formula: 'Generated by specific abilities, consumed for powerful effects',
      useVerb: 'expend',
      gainVerb: 'generate',
      vital: false,
      displayPriority: 3
    },
    {
      id: 'runicPower',
      name: 'Runic Power',
      shortName: 'RP',
      description: 'Death energy used for death knight abilities',
      color: '#519be0',
      icon: 'spell_deathknight_frostpresence',
      defaultMax: 100,
      defaultRegen: 0, // Generated through rune consumption
      regenTrigger: 'runeUsage',
      classRestriction: 'deathKnight',
      affectedBy: ['strength', 'runeUsage'],
      formula: 'Generated by using rune abilities',
      useVerb: 'consume',
      gainVerb: 'generate',
      vital: false,
      displayPriority: 3
    },
    {
      id: 'runes',
      name: 'Runes',
      shortName: 'RN',
      description: 'Magical inscriptions used for death knight abilities',
      color: '#5ec0db',
      icon: 'spell_deathknight_runesofpower',
      defaultMax: 6,
      defaultRegen: 1,
      regenTrigger: 'time',
      regenRate: '10 seconds per rune',
      classRestriction: 'deathKnight',
      affectedBy: ['haste'],
      formula: 'Maximum 6 runes, regenerate over time',
      useVerb: 'consume',
      gainVerb: 'restore',
      vital: false,
      displayPriority: 2
    }
  ];
  
  /**
   * Combined resource types (standard + class-specific)
   */
  export const RESOURCE_TYPES = [...STANDARD_RESOURCE_TYPES, ...CLASS_RESOURCE_TYPES];
  
  /**
   * Resource cost configurations for different effect types
   */
  export const RESOURCE_COSTS = {
    damage: {
      primary: 'actionPoints',
      secondary: 'mana',
      scaling: {
        actionPoints: {
          base: 2,
          perMagnitude: 1,
          max: 5
        },
        mana: {
          base: 10,
          perMagnitude: 5,
          maxPercent: 25 // % of max mana
        }
      },
      alternatives: [
        {
          type: 'health',
          conversionRate: 0.5, // 1 AP = 0.5 health
          name: 'Blood Magic',
          icon: 'spell_shadow_lifedrain'
        },
        {
          type: 'rage',
          conversionRate: 2, // 1 AP = 2 rage
          name: 'Furious Casting',
          icon: 'ability_warrior_rampage'
        }
      ]
    },
    healing: {
      primary: 'actionPoints',
      secondary: 'mana',
      scaling: {
        actionPoints: {
          base: 2,
          perMagnitude: 1,
          max: 5
        },
        mana: {
          base: 15,
          perMagnitude: 8,
          maxPercent: 30 // % of max mana
        }
      },
      alternatives: [
        {
          type: 'health',
          conversionRate: 1.5, // 1 AP = 1.5 health
          name: 'Sacrificial Healing',
          icon: 'spell_holy_sealofsacrifice'
        }
      ]
    },
    buff: {
      primary: 'actionPoints',
      secondary: 'mana',
      scaling: {
        actionPoints: {
          base: 1,
          perMagnitude: 1,
          max: 3
        },
        mana: {
          base: 8,
          perMagnitude: 4,
          maxPercent: 15 // % of max mana
        }
      },
      alternatives: []
    },
    debuff: {
      primary: 'actionPoints',
      secondary: 'mana',
      scaling: {
        actionPoints: {
          base: 1,
          perMagnitude: 1,
          max: 4
        },
        mana: {
          base: 10,
          perMagnitude: 5,
          maxPercent: 20 // % of max mana
        }
      },
      alternatives: []
    },
    utility: {
      primary: 'actionPoints',
      secondary: 'mana',
      scaling: {
        actionPoints: {
          base: 1,
          perMagnitude: 1,
          max: 4
        },
        mana: {
          base: 5,
          perMagnitude: 3,
          maxPercent: 15 // % of max mana
        }
      },
      alternatives: []
    },
    control: {
      primary: 'actionPoints',
      secondary: 'mana',
      scaling: {
        actionPoints: {
          base: 2,
          perMagnitude: 1,
          max: 5
        },
        mana: {
          base: 12,
          perMagnitude: 6,
          maxPercent: 25 // % of max mana
        }
      },
      alternatives: []
    },
    summoning: {
      primary: 'actionPoints',
      secondary: 'mana',
      scaling: {
        actionPoints: {
          base: 3,
          perMagnitude: 1,
          max: 6
        },
        mana: {
          base: 20,
          perMagnitude: 10,
          maxPercent: 40 // % of max mana
        }
      },
      alternatives: [
        {
          type: 'soulShards',
          conversionRate: 0.33, // 1 AP = 0.33 soul shards
          name: 'Soul Summoning',
          icon: 'spell_shadow_soulgem',
          classRestriction: 'warlock'
        }
      ]
    },
    transformation: {
      primary: 'actionPoints',
      secondary: 'mana',
      scaling: {
        actionPoints: {
          base: 2,
          perMagnitude: 1,
          max: 5
        },
        mana: {
          base: 15,
          perMagnitude: 8,
          maxPercent: 30 // % of max mana
        }
      },
      alternatives: []
    }
  };
  
  /**
   * Find a resource type by ID
   * @param {string} id - The ID of the resource type to find
   * @returns {Object|null} The resource type object or null if not found
   */
  export function findResourceById(id) {
    return RESOURCE_TYPES.find(resource => resource.id === id) || null;
  }
  
  /**
   * Get resource types available to a specific class
   * @param {string} className - The class to get resources for
   * @returns {Array} Array of resource types available to the class
   */
  export function getResourcesForClass(className) {
    // Standard resources are available to everyone
    const resources = [...STANDARD_RESOURCE_TYPES];
    
    // Add class-specific resources
    const classResources = CLASS_RESOURCE_TYPES.filter(
      resource => resource.classRestriction === className
    );
    
    return [...resources, ...classResources];
  }
  
  /**
   * Calculate the resource cost for an effect
   * @param {string} effectType - The type of effect
   * @param {number} magnitude - The magnitude or power level of the effect
   * @param {Object} options - Additional options like duration
   * @returns {Object} The calculated resource costs
   */
  export function calculateResourceCost(effectType, magnitude = 1, options = {}) {
    const costConfig = RESOURCE_COSTS[effectType];
    if (!costConfig) return { actionPoints: 1 };
    
    const apScaling = costConfig.scaling.actionPoints;
    const manaScaling = costConfig.scaling.mana;
    
    // Calculate base costs
    let apCost = Math.min(apScaling.base + Math.floor((magnitude - 1) * apScaling.perMagnitude), apScaling.max);
    let manaCost = manaScaling.base + Math.floor((magnitude - 1) * manaScaling.perMagnitude);
    
    // Apply duration modifier
    if (options.duration && options.duration !== 'instant') {
      const durationModifiers = {
        'rounds': 1,
        'minutes': 2,
        'hours': 3,
        'permanent': 4
      };
      
      const durationMod = durationModifiers[options.duration] || 0;
      apCost += durationMod;
      manaCost *= (1 + (durationMod * 0.5));
    }
    
    // Apply targeting modifier
    if (options.targeting) {
      const targetingModifiers = {
        'single': 0,
        'multi': 1,
        'area': 1,
        'chain': 2,
        'self': -1
      };
      
      const targetMod = targetingModifiers[options.targeting] || 0;
      apCost += targetMod;
      manaCost *= (1 + (targetMod * 0.3));
    }
    
    // Apply concentration modifier
    if (options.concentration) {
      apCost += 1;
      manaCost *= 1.2;
    }
    
    // Ensure minimum costs
    apCost = Math.max(1, apCost);
    manaCost = Math.max(5, Math.floor(manaCost));
    
    return {
      actionPoints: apCost,
      mana: manaCost
    };
  }
  
  /**
   * Convert one resource type to another
   * @param {string} fromResource - ID of the resource to convert from
   * @param {string} toResource - ID of the resource to convert to
   * @param {number} amount - Amount of fromResource to convert
   * @returns {Object} Conversion result with fromAmount and toAmount
   */
  export function convertResource(fromResource, toResource, amount) {
    // Find relevant effect types that allow this conversion
    const conversionOptions = [];
    
    for (const [effectType, costConfig] of Object.entries(RESOURCE_COSTS)) {
      const alternatives = costConfig.alternatives || [];
      
      for (const alt of alternatives) {
        if ((alt.type === toResource && costConfig.primary === fromResource) ||
            (alt.type === fromResource && costConfig.primary === toResource)) {
          conversionOptions.push({
            effectType,
            conversionRate: alt.type === fromResource ? 1 / alt.conversionRate : alt.conversionRate,
            name: alt.name
          });
        }
      }
    }
    
    if (conversionOptions.length === 0) {
      return {
        possible: false,
        fromAmount: amount,
        toAmount: 0,
        message: `Cannot convert ${fromResource} to ${toResource}`
      };
    }
    
    // Use the most efficient conversion
    const bestOption = conversionOptions.reduce((best, current) => {
      return current.conversionRate > best.conversionRate ? current : best;
    }, conversionOptions[0]);
    
    return {
      possible: true,
      fromAmount: amount,
      toAmount: Math.floor(amount * bestOption.conversionRate),
      conversionRate: bestOption.conversionRate,
      method: bestOption.name,
      effectType: bestOption.effectType
    };
  }
  
  /**
   * Calculate max resource amount for a character
   * @param {string} resourceId - ID of the resource type
   * @param {Object} character - Character data with stats and level
   * @returns {number} The maximum resource amount
   */
  export function calculateMaxResource(resourceId, character) {
    const resource = findResourceById(resourceId);
    if (!resource) return 0;
    
    const { level, abilityScores, classType } = character || {};
    if (!level || !abilityScores || !classType) return resource.defaultMax;
    
    // Calculate attribute modifiers
    const modifiers = {};
    for (const [ability, score] of Object.entries(abilityScores)) {
      modifiers[`${ability}Mod`] = Math.floor((score - 10) / 2);
    }
    
    // Calculate class bonus
    const classBonuses = {
      // Resource bonuses by class
      actionPoints: {
        mage: 2,
        rogue: 1,
        warrior: 0,
        cleric: 1,
        druid: 1,
        warlock: 2,
        paladin: 0,
        ranger: 1,
        monk: 2,
        barbarian: 0
      },
      mana: {
        mage: 20,
        warlock: 15,
        cleric: 15,
        druid: 15,
        paladin: 10,
        ranger: 5,
        monk: 0,
        rogue: 0,
        warrior: 0,
        barbarian: 0
      },
      health: {
        warrior: 12,
        barbarian: 12,
        paladin: 10,
        ranger: 10,
        monk: 8,
        rogue: 8,
        cleric: 8,
        druid: 8,
        warlock: 6,
        mage: 6
      }
    };
    
    // Handle resource calculation based on ID
    switch (resourceId) {
      case 'actionPoints':
        return 5 + modifiers.intelligenceMod + (classBonuses.actionPoints[classType] || 0) + Math.floor(level / 4);
        
      case 'mana':
        return 100 + (modifiers.intelligenceMod * 10) + (modifiers.spiritMod * 5) + (level * 5) + (classBonuses.mana[classType] || 0);
        
      case 'health':
        const baseHP = classBonuses.health[classType] || 8;
        return baseHP + (modifiers.constitutionMod * level) + (level * baseHP);
        
      case 'energy':
        return 100 + (modifiers.agilityMod * 5) + (modifiers.constitutionMod * 10);
        
      case 'rage':
        return 100;
        
      case 'comboPoints':
        return 5;
        
      case 'soulShards':
        return 5;
        
      case 'holyPower':
        return 5;
        
      case 'focus':
        return 100 + (modifiers.agilityMod * 5) + (level * 2);
        
      case 'ki':
        return modifiers.spiritMod + level;
        
      case 'astralPower':
        return 100;
        
      case 'runicPower':
        return 100;
        
      case 'runes':
        return 6;
        
      default:
        return resource.defaultMax;
    }
  }
  
  /**
   * Calculate resource regeneration amount
   * @param {string} resourceId - ID of the resource type
   * @param {Object} character - Character data
   * @param {string} trigger - What triggered the regeneration
   * @returns {number} The amount of resource regenerated
   */
  export function calculateResourceRegen(resourceId, character, trigger) {
    const resource = findResourceById(resourceId);
    if (!resource) return 0;
    
    // If trigger doesn't match resource's regenTrigger, no regeneration occurs
    if (resource.regenTrigger !== trigger && trigger !== 'all') {
      return 0;
    }
    
    const { level, abilityScores, classType } = character || {};
    if (!level || !abilityScores || !classType) return resource.defaultRegen;
    
    // Calculate attribute modifiers
    const modifiers = {};
    for (const [ability, score] of Object.entries(abilityScores)) {
      modifiers[`${ability}Mod`] = Math.floor((score - 10) / 2);
    }
    
    // Handle resource regeneration calculation based on ID
    switch (resourceId) {
      case 'actionPoints':
        return 3 + Math.floor(modifiers.intelligenceMod / 2);
        
      case 'mana':
        if (trigger === 'rest') {
          return calculateMaxResource('mana', character);
        } else if (trigger === 'combat') {
          return 5 + modifiers.spiritMod;
        }
        return resource.defaultRegen;
        
      case 'health':
        if (trigger === 'rest') {
          return Math.floor(calculateMaxResource('health', character) / 2);
        } else if (trigger === 'outOfCombat') {
          return modifiers.constitutionMod * 2;
        }
        return resource.defaultRegen;
        
      case 'energy':
        return 10 + modifiers.agilityMod;
        
      case 'rage':
        if (trigger === 'combat') {
          return 0; // Generated through combat actions
        } else if (trigger === 'outOfCombat') {
          return -5; // Degenerates
        }
        return resource.defaultRegen;
        
      default:
        return resource.defaultRegen;
    }
  }
  
  /**
   * Get resource cost text for an effect
   * @param {Object} costs - Object with resource costs
   * @returns {string} Formatted resource cost text
   */
  export function getResourceCostText(costs) {
    const parts = [];
    
    for (const [resourceId, amount] of Object.entries(costs)) {
      if (amount <= 0) continue;
      
      const resource = findResourceById(resourceId);
      if (!resource) continue;
      
      parts.push(`${amount} ${resource.shortName || resource.name}`);
    }
    
    return parts.join(', ');
  }
  
  /**
   * Check if a character has enough resources for an effect
   * @param {Object} character - Character data with current resources
   * @param {Object} costs - Required resource costs
   * @returns {Object} Result with success flag and message
   */
  export function checkResourceRequirements(character, costs) {
    if (!character || !character.resources || !costs) {
      return { success: false, message: 'Invalid data provided' };
    }
    
    const missingResources = [];
    
    for (const [resourceId, amount] of Object.entries(costs)) {
      if (amount <= 0) continue;
      
      const currentAmount = character.resources[resourceId] || 0;
      if (currentAmount < amount) {
        const resource = findResourceById(resourceId);
        const resourceName = resource ? resource.name : resourceId;
        missingResources.push({
          id: resourceId,
          name: resourceName,
          required: amount,
          current: currentAmount,
          missing: amount - currentAmount
        });
      }
    }
    
    if (missingResources.length === 0) {
      return { success: true };
    }
    
    const message = missingResources.map(r => 
      `Need ${r.missing} more ${r.name} (${r.current}/${r.required})`
    ).join(', ');
    
    return {
      success: false,
      message: `Insufficient resources: ${message}`,
      missingResources
    };
  }